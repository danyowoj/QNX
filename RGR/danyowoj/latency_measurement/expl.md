## **0. Компиляция и запуск**

```bash
# компиляция
make clean
make all
```

```bash
# запуск контроллера в одном терминале
on -C 0 ./controller 2696000000 w1 w2
# 2696000000 -- частота ЦПУ в Гц
```

```bash
# запуск рабочихъ процессов в двух разных терминалах
on -C 0 ./worker w1 /mq_results &

on -C 0 ./worker w2 /mq_results &
```

## **1. Цель работы**

Цель работы — изучить, как операционная система QNX планирует выполнение потоков при разных приоритетах, и как это влияет на задержку пробуждения потоков после вызова `nanosleep()`.

Для измерений используется высокоточный счётчик процессора (`ClockCycles()` / `clock_gettime()`), а запуск программы производится на одном ядре с помощью команды:

```
on -C 0 ./controller
```

Это исключает влияние миграции потоков между процессорами.

---

## **2. Принцип работы программы**

Программа состоит из одного процесса-контроллера и двух рабочих потоков.

### Что делает каждый рабочий поток:

1. Получает свой приоритет.
2. Засыпает на 1 миллисекунду:

   ```c
   nanosleep(1 ms)
   ```
3. После пробуждения измеряет, сколько реально прошло времени.
4. Записывает результат в массив из 1000 измерений.

Фактически поток измеряет **ошибку пробуждения**, или **латентность**, которая показывает, насколько хаотично и непредсказуемо срабатывает системный таймер.

### Что делает контроллер:

1. Создаёт два рабочих потока.

2. Задает им разные приоритеты по четырём сценариям:

   | Тест | w1 | w2 |
   | ---- | -- | -- |
   | 0    | 10 | 5  |
   | 1    | 5  | 10 |
   | 2    | 10 | 10 |
   | 3    | 5  | 5  |

3. Ждёт завершения потоков.

4. Собирает статистику по задержкам:

   * минимальная
   * максимальная
   * средняя
   * стандартное отклонение

5. Выводит результаты.

Алгоритм простой: **пусть потоки спят одинаковое время, но с разными приоритетами — затем сравним, кто просыпается точнее.**

---

## **3. Основная идея измерений**

В QNX используется **вытесняющее планирование по приоритетам**, где:

* поток с более высоким приоритетом получает процессор сразу после пробуждения;
* поток с низким приоритетом может ждать, если процессор занят;
* потоки с одинаковым приоритетом работают по принципу round-robin (чередование по квантам).

Поэтому задержка пробуждения (latency) — хороший показатель:

* насколько стабильно поток получает управление,
* насколько сильно он вытесняется другими потоками.

---

## **4. Анализ результатов эксперимента**

Ниже приведён анализ тех данных, которые вы получили.

---

### **Тест 0: w1=10, w2=5**

Высокий приоритет:

```
w1 mean ≈ 1150 ns (очень маленькая задержка)
```

Низкий приоритет:

```
w2 mean ≈ 4300 ns (в 3–4 раза хуже)
```

**Вывод:**
Планировщик работает корректно — поток с высоким приоритетом пробуждается быстрее и стабильнее.

---

### **Тест 1: w1=5, w2=10**

Приоритеты поменялись местами. Теперь:

```
w2 (prio=10) mean ≈ 2340 ns  
w1 (prio=5)  mean ≈ 5586 ns  
```

Но в этом тесте у обоих потоков огромные скачки:

* max задержки доходят до **0.6–0.7 миллисекунды**
* стандартное отклонение ≈ **20 000 ns**

**Вывод:**
На системе в этот момент явно была дополнительная нагрузка: прерывания, драйверы или другие высокоприоритетные потоки.
Задержки стали нестабильными для обоих потоков.

---

### **Тест 2: w1=10, w2=10**

Одинаковые высокие приоритеты.

```
w1 mean ≈ 1360 ns  
w2 mean ≈ 3494 ns  
```

Хотя приоритет один и тот же, потоки работают по очереди, и планировщик распределяет квант времени не идеально — из-за этого задержки отличаются.

Также заметны редкие скачки задержек (до 0.6 ms), вероятно из-за системных прерываний.

**Вывод:**
Даже одинаковый приоритет не гарантирует одинаковое поведение потоков.

---

### **Тест 3: w1=5, w2=5**

Одинаковые низкие приоритеты.

```
w1 mean ≈ 3694 ns  
w2 mean ≈ 5654 ns  
```

Оба потока испытывают задержки больше, чем потоки с приоритетом 10.
Это связано с тем, что низкоприоритетные потоки чаще вытесняются системой и драйверами.

**Вывод:**
Низкий приоритет приводит к худшей временной точности.

---

## **5. Общие выводы**

1. **Высокий приоритет значительно уменьшает задержки пробуждения.**
   Это подтверждается тестами 0 и 1.

2. **Низкоприоритетные потоки всегда проигрывают в стабильности и точности.**

3. **При равных приоритетах возникают различия из-за round-robin-планирования**, поскольку короткие задачи по-разному вписываются в кванты времени.

4. **Большие скачки до 0.7 ms указывают на системные прерывания**, которые невозможно полностью убрать без полного контроля над системой.

5. QNX показывает типичное поведение системы реального времени:

   * чем выше приоритет — тем меньше разброс задержек,
   * чем ниже приоритет — тем больше влияние фона и IRQ.
