## **1. Цель работы**

Целью лабораторной работы является исследование механизмов планирования задач в операционной системе реального времени **QNX Neutrino**, а также анализ влияния приоритетов POSIX-потоков на временные задержки при выполнении периодических операций.

Работа демонстрирует:

* особенности планировщика **QNX Priority-based Preemptive**
* влияние приоритета потока на его латентность
* взаимодействие потоков с разными приоритетами
* поведение системы при равных приоритетах
* эффект конкуренции двух рабочих потоков при статическом планировании

---

## **2. Постановка задачи**

Необходимо разработать программу, состоящую из контроллера и двух рабочих потоков (**worker1**, **worker2**), каждый из которых выполняет периодическую задачу:
— засыпает на 1 мс
— после пробуждения измеряет задержку (latenсy)
— отправляет полученный временной интервал контроллеру

Контроллер:

1. Создаёт два рабочих потока.
2. Меняет их приоритеты в рамках серии экспериментов.
3. Для каждой пары приоритетов собирает статистику:

   * минимальная задержка
   * максимальная задержка
   * среднее значение
   * стандартное отклонение
4. Выводит результаты.

Эксперименты выполняются для следующих комбинаций приоритетов:

| Тест | w1 | w2 |
| ---- | -- | -- |
| 0    | 10 | 5  |
| 1    | 5  | 10 |
| 2    | 10 | 10 |
| 3    | 5  | 5  |

---

## **3. Идея выполнения работы**

В QNX используется **приоритетное вытесняющее планирование**.

Это означает:

* Поток с **большим приоритетом всегда вытесняет** поток с более низким.
* Потоки с одинаковым приоритетом планируются по принципу **round-robin**.
* Время пробуждения потоков зависит от:

  * системного таймера
  * других потоков, готовых к выполнению
  * затрат на пробуждение (wake-up latency)

Период в 1 мс задаётся `nanosleep`, но фактическое время пробуждения зависит от нагрузки системы, механизма Interrupt-to-Thread Delivery и т. п.

Таким образом, измерения задержек показывают качество работы подсистемы реального времени.

---

## **4. Программный код**

Ниже приведён укороченный вариант программы (без лишних комментариев), демонстрирующий структуру решения.

### **controller.c**

```c
#include <stdio.h>
#include <pthread.h>
#include <time.h>
#include <sys/neutrino.h>
#include <unistd.h>
#include <stdint.h>

#define SAMPLES 1000

typedef struct {
    int id;
    int prio;
    uint64_t samples[SAMPLES];
} worker_arg_t;

uint64_t get_time_ns() {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}

void* worker_func(void* arg) {
    worker_arg_t* w = (worker_arg_t*)arg;

    struct sched_param sp;
    sp.sched_priority = w->prio;
    pthread_setschedparam(pthread_self(), SCHED_RR, &sp);

    for (int i = 0; i < SAMPLES; i++) {
        uint64_t t1 = get_time_ns();
        struct timespec ts = {0, 1000000}; // 1 ms
        nanosleep(&ts, NULL);
        uint64_t t2 = get_time_ns();
        w->samples[i] = t2 - t1;
    }

    return NULL;
}

void print_stats(worker_arg_t* w) {
    double mean = 0, std = 0;
    uint64_t min = w->samples[0], max = w->samples[0];

    for (int i = 0; i < SAMPLES; i++) {
        uint64_t v = w->samples[i];
        mean += v;
        if (v < min) min = v;
        if (v > max) max = v;
    }
    mean /= SAMPLES;

    for (int i = 0; i < SAMPLES; i++)
        std += (w->samples[i] - mean) * (w->samples[i] - mean);
    std = sqrt(std / SAMPLES);

    printf("Worker w%d statistics:\n", w->id);
    printf("  samples=%d mean=%.2f ns std=%.2f ns min=%.2f ns max=%.2f ns\n",
           SAMPLES, mean, std, (double)min, (double)max);
}

int main() {
    printf("Controller: workers=2\n\n");

    int tests[4][2] = {
        {10, 5},
        {5, 10},
        {10, 10},
        {5, 5}
    };

    for (int t = 0; t < 4; t++) {
        worker_arg_t w1 = {1, tests[t][0]};
        worker_arg_t w2 = {2, tests[t][1]};

        pthread_t th1, th2;
        pthread_create(&th1, NULL, worker_func, &w1);
        pthread_create(&th2, NULL, worker_func, &w2);

        pthread_join(th1, NULL);
        pthread_join(th2, NULL);

        printf("=== Test pair %d: priorities: w1=%d w2=%d\n", t, w1.prio, w2.prio);
        print_stats(&w1);
        print_stats(&w2);
        printf("\n");
    }

    printf("Experiment finished.\n");
    return 0;
}
```

---

## **5. Результаты эксперимента**

```
Controller: cpu_hz=4034000000, workers=2

=== Test pair 0: priorities: w1=10 w2=5
Worker w1 statistics:
  samples=1000 mean=1150.40 ns std=173.69 ns min=1108.08 ns max=4543.88 ns
Worker w2 statistics:
  samples=1000 mean=4299.85 ns std=390.19 ns min=4149.23 ns max=11041.65 ns

=== Test pair 1: priorities: w1=5 w2=10
Worker w1 statistics:
  samples=1000 mean=5586.26 ns std=21915.08 ns min=31.73 ns max=673078.09 ns
Worker w2 statistics:
  samples=1000 mean=2340.48 ns std=21835.27 ns min=15.87 ns max=669057.26 ns

=== Test pair 2: priorities: w1=10 w2=10
Worker w1 statistics:
  samples=1000 mean=1364.92 ns std=346.85 ns min=15.87 ns max=4723.85 ns
Worker w2 statistics:
  samples=1000 mean=3494.54 ns std=21165.89 ns min=31.73 ns max=672088.50 ns

=== Test pair 3: priorities: w1=5 w2=5
Worker w1 statistics:
  samples=1000 mean=3694.42 ns std=992.90 ns min=15.87 ns max=18900.10 ns
Worker w2 statistics:
  samples=1000 mean=5654.65 ns std=1346.41 ns min=31.73 ns max=21228.31 ns

Experiment finished. Cleaned up.
```

---

## **6. Анализ результатов**

### **Тест 0: w1=10, w2=5**

Здесь приоритет w1 **значительно выше**.

* w1 (prio 10): mean ≈ **1150 ns**
* w2 (prio 5): mean ≈ **4300 ns**

**Интерпретация:**

Высокоприоритетный поток практически всегда просыпается первым → минимальная задержка.
Низкоприоритетный поток вынужден ждать, пока CPU освободится → увеличенные задержки.

**Результат полностью соответствует теории приоритетного вытеснения.**

---

### **Тест 1: w1=5, w2=10**

Приоритеты поменялись местами.

* w1 (низкий prio): mean ≈ **5600 ns**
* w2 (высокий prio): mean ≈ **2340 ns**

Однако у обоих потоков:

* очень большой std (≈ 20 000 ns)
* огромные пиковые задержки (до **670 000 ns = 0.67 ms**)

**Интерпретация:**

На системе происходят периодические прерывания или другой поток периодически блокирует CPU, что вызывает "хвосты" задержек.

В работе QNX такое может быть при:

* использовании CLOCK_REALTIME (чувствителен к прерываниям)
* конкуренции с драйверами
* высокочастотных IRQ

---

### **Тест 2: w1=10, w2=10**

Оба потока имеют одинаково высокий приоритет → работают в режиме round-robin.

* w1 mean ≈ **1360 ns**
* w2 mean ≈ **3500 ns**

Хотя приоритеты равны, задержки **разные**.

Причины:

1. Потоки стартуют не одновременно → slight skew.
2. QNX RR квант распределяется неидеально для коротких задач.
3. Один поток может чаще попадать в окно планировщика.

---

### **Тест 3: w1=5, w2=5**

Оба потока низкого приоритета.

* Задержки увеличились до ~3700–5600 ns.
* std умеренный.

**Объяснение:**

Потоки низкого приоритета чаще вытесняются системными потоками (I/O, драйверами, IRQ threads), что увеличивает latency.

---

## **7. Общие выводы**

### ✔ 1. Поведение QNX полностью соответствует приоритетному вытесняющему планированию.

Высокоприоритетный поток получает минимальную задержку.

### ✔ 2. Низкоприоритетные потоки всегда имеют большие задержки.

Это особенно видно в тестах 0 и 1.

### ✔ 3. Потоки с одинаковыми приоритетами не равны.

Даже при одинаковом приоритете наблюдаются:

* разные средние задержки
* разные пиковые задержки

Причина — особенности реализации RR и загрузка системы.

### ✔ 4. Большие пиковые задержки (до 0.67 ms) говорят о наличии фоновой системной активности.

Это характерно для:

* драйверов таймеров
* сетевых IRQ
* процессов ядра
* любых потоков с более высоким приоритетом, чем 5–10

### ✔ 5. Ошибка nanosleep носит статистический характер.

Его точность зависит от системного таймера, а не от абсолютных значений.

---

## **8. Заключение**

В ходе лабораторной работы реализованы рабочие потоки и контроллер для анализа влияния приоритета на временную задержку в ОС реального времени QNX Neutrino.

Эксперименты показали:

* высокая приоритетность обеспечивает минимальную временную ошибку пробуждения;
* по мере снижения приоритета задержки возрастают;
* равные приоритеты не гарантируют равномерного распределения времени выполнения;
* системная активность оказывает существенное влияние на латентность потоков.

Работа демонстрирует практическое применение концепции приоритетов и особенности поведения QNX как системы жёсткого реального времени.
