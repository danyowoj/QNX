# Краткое объяснение принципа работы программы и её алгоритма

Цель программы — **измерить время контекстного переключения между двумя нитями** внутри одного процесса. Для максимально точного результата используется **аппаратный счётчик тактов процессора (ClockCycles)**, а выполнение процесса привязывается к одному CPU.

---

## Принцип работы программы

Программа создаёт две нити:

1. **Основная нить (parent)**
2. **Рабочая нить (worker)**

Эти нити по очереди «передают» управление друг другу при помощи:

* мьютекса,
* двух условных переменных,
* общего флага `turn`, указывающего, какая нить должна работать.

Каждая передача управления инициирует **контекстное переключение**, которое и измеряется.

Для измерения используется функция `ClockCycles()`, позволяющая получить текущее значение аппаратного таймера в тактах CPU.
Чтобы корректно перевести число тактов в наносекунды, программа сначала получает частоту процессора:

* из системной таблицы `syspage`,
* или, если значение неверное, выполняет **калибровку** путём измерения количества тактов за известную задержку (100 мс).

---

## Алгоритм работы программы

1. **Получить частоту процессора**

   * Прочитать `cpuinfo->speed`.
   * Если значение подозрительное → измерить частоту вручную через ClockCycles().

2. **Создать рабочую нить** (`worker`).

3. **Для каждой итерации измерения (N раз):**

   * Основная нить:

     * фиксирует время `t0 = ClockCycles()`,
     * передаёт управление рабочей нити (turn=1),
     * ждёт, пока worker вернёт управление.
   * Рабочая нить:

     * просыпается и фиксирует время `t1 = ClockCycles()`.

4. **Записать разницу времени:**
   `delta = t1 - t0` — это время переключения *parent → worker*.

5. **После завершения измерений:**

   * вычислить среднее количество циклов,
   * перевести в наносекунды по формуле:
     `ns = cycles / cpu_hz * 1e9`,
   * вывести:

     * среднее время полного переключения,
     * оценку времени **одного** переключения
       (половина полного времени parent→worker→parent).
