## **Принцип работы программы**

Программа демонстрирует поведение планировщика QNX при изменении приоритета нити. Основная цель — проверить, **вызовет ли перепланирование нити, если она подтверждает свой текущий приоритет** или повышает его.

---

## **Алгоритм программы**

1. **Создание рабочей нити (worker):**

   * Нить выполняет бесконечный цикл, в котором регулярно обновляет глобальную переменную `worker_last_run = ClockCycles()`.
   * Для безопасности добавляется короткая пауза (`msleep(1)`), чтобы не блокировать систему.

2. **Настройка приоритетов:**

   * Главная нить (`controller`) и worker получают приоритеты в допустимом диапазоне.
   * Планируется два эксперимента:

     * **Эксперимент A:** подтверждение того же приоритета у worker.
     * **Эксперимент B:** повышение приоритета worker выше контроллера.

3. **Эксперимент A — подтверждение приоритета:**

   * Вызывается `pthread_setschedparam(worker, policy, same_priority)`.
   * Программа замеряет `ClockCycles()` до и после установки приоритета.
   * Наблюдается, что worker не получает CPU мгновенно — перепланирование не происходит.

4. **Эксперимент B — повышение приоритета:**

   * Приоритет worker увеличивается выше приоритета контроллера.
   * После этого worker сразу получает CPU (preemption), что видно по обновлению `worker_last_run`.

5. **Завершение программы:**

   * Главная нить останавливает worker (`stop_worker = 1`) и ждёт завершения с помощью `pthread_join()`.

---

## **Итог**

* **Подтверждение текущего приоритета** — перепланирования не происходит.
* **Повышение приоритета** — немедленное перепланирование и передача CPU рабочей нити.
